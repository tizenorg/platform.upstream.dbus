#!/usr/bin/expect

set TARGET_HOST "foxp2"
set ROOT_DIR "/root"
set NUM_PASSES 3
#set DATA_SIZE_BYTES 1024
set RESULT_FILE [clock format [clock seconds] -format "latency-results-%Y.%m.%d.%H.%M.%S.csv"]

set INVOCATIONS [list \
    { "TTV default" "DISPLAY=:0 " } \
    [list "Custom lib, kdbus transport" "LD_LIBRARY_PATH=$ROOT_DIR/libs DBUS_SESSION_BUS_ADDRESS='kdbus:path=/dev/kdbus/0-kdbus/bus'"] \
]

#    [list "Custom lib, dbus transport" "DISPLAY=:0 LD_LIBRARY_PATH=$ROOT_DIR/libs"] \

set DATA_SIZES_BYTES { 10 100 1024 10240 102400 1048576 10485760 }

#set PROBES { \
#    1000   { 1000 } \
#    2000   { 1000 2000 } \
#    5000   { 1000 2000 5000 } \
#    10000  { 1000 2000 5000 10000 } \
#    20000  { 1000 2000 5000 10000 20000 } \
#    50000  { 1000 2000 5000 10000 20000 50000 } \
#    75000  { 1000 2000 5000 10000 20000 50000 75000 } \
#    100000 { 1000 2000 5000 10000 20000 50000 75000 } \
#    200000 { 1000 2000 5000 10000 20000 50000 75000 } \
#    300000 { 1000 2000 5000 10000 20000 50000 75000 } \
#}


# ***************************************************************************************************************************************************


proc run_server { invocation } {
    global TARGET_HOST ROOT_DIR
    spawn ssh -t $TARGET_HOST "cd $ROOT_DIR/ipc-test; $invocation ./ping-server"
    expect {
        "Waiting for clients"    { return $spawn_id }
        default                 {
            puts ">>> ERROR <<<"
            #puts $expect_out(buffer)
            puts ">>> ----- <<<"
            return 0
        }
    }
}


proc terminate_server { server_id } {
    set spawn_id $server_id
    send "\x03"
    expect {
        "closed."   { return 1 }
        default     { return 0 }
    }
}


proc run_client { invocation data_size_bytes} {
    global TARGET_HOST ROOT_DIR
    spawn ssh -t $TARGET_HOST "$invocation $ROOT_DIR/ipc-test/ping-client $data_size_bytes"
    set round_trip_time 0
    expect  {
        -timeout 60
        -re {avg RTT: (\d+) us} {
            set round_trip_time $expect_out(1,string)
        }
        timeout { puts "ctrl-C"; send "\x03" }
    }
    return $round_trip_time
}


proc log_result { data { new_file 0 } } {
    global RESULT_FILE
    if { $new_file } {
        puts "Storing results into file $RESULT_FILE"
    }
    set pl [open $RESULT_FILE [expr {$new_file ? "w" : "a"}]]
    puts $pl [join $data ","]
    close $pl
}

# ***************************************************************************************************************************************************


log_user 0

log_result { {"Test environment"} {Data size [Bytes]} {"Round Trip Time [ms]"} } 1

# iterate over different invocations
foreach invocation $INVOCATIONS {
    set test_env [lindex $invocation 0]
    puts "Test environment: $test_env"
    puts ""
    puts -nonewline "Bringing up server... "
    set server [run_server [lindex $invocation 1]]
    if { $server == 0 } {
        puts "failed!"
        continue
    }
    puts "OK!"        
    puts "Test start, passes: $NUM_PASSES"    
    flush stdout
    
    for { set p 0 } { $p < [llength $DATA_SIZES_BYTES] } { incr p } {
      set data_size_bytes [lindex $DATA_SIZES_BYTES $p]
      # average several passes to get more stable figures
      set total 0
      set passes 0
      for { set run 1 } { $run <= $NUM_PASSES } { incr run } {
	  set result [run_client [lindex $invocation 1] $data_size_bytes]
	  if { $result >= 0 } {
	      puts -nonewline "."
	      #puts "iteration $passes, data_size: $data_size_bytes : $result us"
	      incr total $result
	      incr passes
	  } else {
	      puts -nonewline "!"
	  }
	  flush stdout
      }
      if { $passes > 0 } {
	  set avg [expr $total / $passes]
	  puts " data_size $data_size_bytes B  $avg us"
	  log_result [list "\"$test_env\"" $data_size_bytes $avg]
      } else {
	  puts " no results!"
      }
      #puts " data_size: $data_size_bytes"
    }
    
    flush stdout
        
    
    puts -nonewline "Terminating server... "
    terminate_server $server
    puts "OK!"
    puts ""
}

log_user 1

